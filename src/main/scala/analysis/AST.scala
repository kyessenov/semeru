package edu.mit.csail.cap.query
package analysis.ast

import scala.collection.mutable

sealed trait Syntax

sealed trait Statement extends Syntax {
  /** Source event */
  def e: Event

  /** Required values for execution */
  def uses: List[Val] = this match {
    case s: NewArray        => Nil
    case s: Call            => s.params ++ s.receiver
    case s: New             => s.params
    case s: FieldDeref      => s.receiver.toList
    case s: ArrayDeref      => List(s.receiver, s.index)
    case s: FieldAssignment => List(s.v) ++ s.receiver
    case s: ArrayAssignment => List(s.receiver, s.v, s.index)
    case s: Return          => List(s.v)
    case s: Throw           => List(s.v)
  }

  /** Produced values */
  def vals: List[Val] = uses ++ {
    this match {
      case s: Producer => List(s.result)
      case _           => Nil
    }
  }

  /** Must map variables to variables */
  def apply(f: Val => Val) = this match {
    case NewArray(e, result, base)                 => NewArray(e, f(result).asInstanceOf[Var], base)
    case Call(e, result, receiver, method, params) => Call(e, f(result).asInstanceOf[Var], receiver.map(f), method, params.map(f))
    case New(e, result, constructor, params)       => New(e, f(result).asInstanceOf[Var], constructor, params.map(f))
    case FieldDeref(e, result, receiver, field)    => FieldDeref(e, f(result).asInstanceOf[Var], receiver.map(f), field)
    case ArrayDeref(e, result, array, index)       => ArrayDeref(e, f(result).asInstanceOf[Var], f(array), f(index))
    case FieldAssignment(e, receiver, field, v)    => FieldAssignment(e, receiver.map(f), field, f(v))
    case ArrayAssignment(e, receiver, v, index)    => ArrayAssignment(e, f(receiver), f(v), f(index))
    case Return(e, v, method)                      => Return(e, f(v), method)
    case Throw(e, v)                               => Throw(e, f(v))
  }

  def substitute(m: PartialFunction[Val, Val]) = apply {
    case v if m.isDefinedAt(v) => m(v)
    case v                     => v
  }
}

sealed trait Producer extends Statement {
  /** Variable are produced once (like in SSA) */
  def result: Var
}

case class NewArray(e: Event, result: Var, base: Type) extends Producer
case class Call(e: Event, result: Var, receiver: Option[Val], method: Method, params: List[Val]) extends Producer
case class New(e: Event, result: Var, constructor: ClassType, params: List[Val]) extends Producer
sealed trait Deref extends Producer
case class FieldDeref(e: Event, result: Var, receiver: Option[Val], field: Field) extends Deref
case class ArrayDeref(e: Event, result: Var, receiver: Val, index: Val) extends Deref
case class FieldAssignment(e: Event, receiver: Option[Val], field: Field, v: Val) extends Statement
case class ArrayAssignment(e: Event, receiver: Val, v: Val, index: Val) extends Statement
case class Return(e: Event, v: Val, method: Method) extends Statement
case class Throw(e: Event, v: Val) extends Statement

sealed trait Val extends Syntax {
  /** Source value */
  def o: Object

  /** Declared type */
  def typ: Type
}

object Var {
  var i = 0

  def apply(o: Object, typ: Type): Var = {
    i = i + 1
    Var(i, o, typ)
  }

  /** Generate a fresh name by adding a counter suffix */
  def fresh(prefix: String, existing: Set[String]): String = {
    var i = 0
    var name: String = prefix
    while (existing.contains(name)) {
      name = prefix + i.toString
      i = i + 1
    }
    name
  }
}

case class Var private (id: Int, o: Object, typ: Type) extends Val {
  def literal = Literal(o, typ)
  def unknown = Var(o, UnknownType)
}

case class Literal(o: Object, typ: Type) extends Val
case class This(o: Object, typ: Type) extends Val
case class Super(o: Object, typ: Type) extends Val

object NullVal extends Val {
  override def o = Null
  override def typ = NullType
}

case class UnknownVal(o: Object = Unknown) extends Val {
  override def typ = UnknownType
}

case class Environment(
    global: Map[JavaElement, String],
    local: mutable.Map[Var, String],
    b: FrameworkBoundary,
    c: Connection,
    p: Parameters) extends (JavaElement => String) {

  def make(mb: MethodBody) = copy(
    local = new mutable.HashMap[Var, String] ++ mb.arguments.zipWithIndex.map { case (a, i) => (a, s"a$i") })

  override def apply(elt: JavaElement) = global.get(elt) match {
    case Some(name) => name
    case None => elt match {
      case t: ClassType => t.prettyName
      case ArrayType(t) => apply(t) + "[]"
      case _            => elt.name
    }
  }
}

sealed trait Declaration extends Syntax

/** Linear sequence of statements generated by a call event */
case class MethodBody(place: Enter, receiver: Option[This], arguments: List[Var], stmts: List[Statement] = Nil) extends Declaration {
  def method = place.method
  def meta = method.declarer.meta

  def initial: List[Val] = arguments ++ receiver

  def size = stmts.size

  def calls: Set[Method] =
    stmts.collect { case s: Call => s.method }.toSet

  def assigns: Set[Field] =
    stmts.collect { case s: FieldAssignment => s.field }.toSet

  def dereferences: Set[Field] =
    stmts.collect { case s: FieldDeref => s.field }.toSet

  /** Referenced types */
  def types: Set[Type] = {
    for (
      s <- stmts;
      v <- s.vals.collect { case v: Var => v }
    ) yield v.typ
  }.toSet

  /** Apply substitution */
  def substitute(m: Map[Val, Val]) =
    copy(stmts = stmts.map(_.substitute(m)))

  /** Replace calls to this by calls to super for overridden methods */
  def replaceThisBySuper = copy(stmts = stmts.map {
    case Call(e, result, Some(t: This), m, params) if method.overridden.contains(m) =>
      Call(e, result, Some(Super(t.o, t.typ)), m, params)
    case s => s
  })

  /** Skip double reads of fields for values in scope */
  def removeDoubleDerefs = {
    var defined = initial.toSet
    var map = Map[Val, Val]()
    val out = stmts.flatMap {
      case s: FieldDeref => defined.find(_.o == s.result.o) match {
        case Some(v) =>
          map += s.result -> v; None
        case None =>
          defined += s.result; Some(s)
      }
      case s: Producer =>
        defined += s.result; Some(s)
      case s => Some(s)
    }
    copy(stmts = out).substitute(map)
  }

  /** Remove return result variables if they are not used but keep the call */
  def removeUnusedReturns = {
    var used = Set[Val]()
    val out = stmts.reverse.map {
      case s: Call =>
        val result = s.result match { case v if used.contains(v) => v; case v => v.unknown }
        used ++= s.uses; s.copy(result = result)
      case s =>
        used ++= s.uses; s
    }
    copy(stmts = out.reverse)
  }

  /** Remove user constructors that are kept in projection 
   *  (directly or as parameters to user constructors) 
   *  Also remove static initializers. */
  def removeUnusedConstructors(implicit b: FrameworkBoundary) = {
    val used = stmts.flatMap(_.uses).toSet
    copy(stmts = stmts.flatMap {
      case s: New if !used(s.result) && b.isUser(s.constructor) => None
      case s: Call if s.method.isStaticInitializer => None
      case s => Some(s)
    })
  }

  def removeUnusedFrameworkConstructors(implicit b: FrameworkBoundary) = {
    val used = stmts.flatMap(_.uses).toSet
    copy(stmts = stmts.flatMap {
      case s: New if !used(s.result) && b.isFramework(s.constructor) => None
      case s => Some(s)
    })
  }

  def sameArgs(args: List[Val]): Boolean = (args zip arguments zip place.arguments).forall {
    case ((arg, formal), actual) => arg == formal || arg.o == actual
  }

  /** Remove trivial bodies like calls to super */
  def removeTrivialBody =
    if (stmts match {
      case Call(_, _, Some(_: Super), _, args) :: Nil if sameArgs(args) =>
        true
      case Call(_, x1, Some(_: Super), _, args) :: (r: Return) :: Nil if sameArgs(args) && x1 == r.v => true
      case _ => false
    }) copy(stmts = Nil)
    else
      this

  /** Add new array statements for array literals */
  def addNewArrays = {
    val map = new mutable.HashMap[Val, Val]
    copy(stmts = stmts.flatMap { stmt =>
      val literals = stmt.vals.distinct.collect {
        case l @ Literal(o, _: ArrayType) if !map.contains(l) => l
      }
      val vars = for (l <- literals) yield Var(l.o, l.typ)
      for ((l, v) <- literals zip vars) map += l -> v
      val inits = for (v <- vars) yield NewArray(stmt.e, v, v.typ.base)
      inits :+ stmt.substitute(map)
    })
  }

  /** Value may escape the local context (except use as receiver) */
  lazy val escapes: Set[Val] = stmts.flatMap {
    case _: NewArray | _: Deref => Nil
    case s: Call                => s.params
    case s: New                 => s.params
    case s: FieldAssignment     => List(s.v)
    case s: ArrayAssignment     => List(s.v)
    case s: Return              => List(s.v)
    case s: Throw               => List(s.v)
  }.toSet

  /** Remove locally created containers that cannot escape the local context */
  def removeLocalContainers: MethodBody = {
    // locally created or derived constructors
    // group by following call chains from container to container
    val locals = new mutable.HashSet[mutable.Set[Val]]
    for (s <- stmts) s match {
      case s: New if meta.containers(s.constructor) => locals += (new mutable.HashSet + s.result)
      case s: NewArray                              => locals += (new mutable.HashSet + s.result)
      case s: Call if s.receiver.isDefined && meta.containers(s.result.typ) =>
        locals.find(_.contains(s.receiver.get)) match {
          case Some(local) => local += s.result
          case _           =>
        }
      case _ =>
    }

    // if anything escapes, cancel group
    val local = locals.filter {
      case local => (local intersect escapes).isEmpty
    }.flatten

    if (local.size > 0) debug("removeLocalContainers: " + local)

    // substitute result variables
    // lookup preceding produced values or make literal otherwise
    var defined = initial.map(v => (v.o, v)).toMap
    var map = Map[Val, Val]()
    val out = copy(stmts = stmts.flatMap {
      case s: New if local(s.result)               => None
      case s: NewArray if local(s.result)          => None
      case s: ArrayAssignment if local(s.receiver) => None
      case s: ArrayDeref if local(s.receiver) =>
        map += s.result -> defined.getOrElse(s.result.o, s.result.literal)
        None
      case s: Call if s.receiver.isDefined && local(s.receiver.get) =>
        map += s.result -> defined.getOrElse(s.result.o, s.result.literal)
        None
      case s: Producer =>
        defined += s.result.o -> s.result
        Some(s)
      case s =>
        Some(s)
    })
    out.substitute(map)
  }

  /** Compute typing constraints from values of the given type */
  def typing(ct: ClassType): Set[ClassType] = {
    for (s <- stmts) yield s match {
      case s: Call =>
        s.receiver.toList.collect { case v if v.typ == ct => s.method.declarer } :::
          (s.params zip s.method.parameterTypes).collect { case (v, t: ClassType) if v.typ == ct => t }
      case s: FieldDeref =>
        s.receiver.toList.collect { case v if v.typ == ct => s.field.declarer }
      case s: FieldAssignment =>
        s.receiver.toList.collect { case v if v.typ == ct => s.field.declarer } :::
          List(s.v).collect { case v if v.typ == ct => s.field.typ }
      case s: ArrayAssignment =>
        List(s.v).collect { case v if v.typ == ct => s.receiver.typ.base }
      case s: Return =>
        List(s.v).collect { case v if v.typ == ct => s.method.returnType }
      case _: New | _: NewArray | _: ArrayDeref | _: Throw => Nil
    }
  }.toSet.flatten.collect { case t: ClassType => t }
}

case class MethodBodies(b: FrameworkBoundary, initial: Set[Event], bodies: List[MethodBody]) {
  def size = bodies.map(_.size).sum

  /** If a user field is never read, delete the assignment */
  def removeOwnedFields = {
    val owned =
      bodies.flatMap(_.assigns).toSet[Field].filter(b.isUser) -- bodies.flatMap(_.dereferences)
    if (owned.size > 0) debug("removeOwnedFields: " + owned.map(_.name).mkString(", "))
    val out = for (b <- bodies)
      yield b.copy(stmts = b.stmts.filterNot {
      case s: FieldAssignment if owned(s.field) => true
      case _                                    => false
    })

    copy(bodies = out)
  }

  /** Remove empty bodies except seeds */
  def removeEmpty =
    copy(bodies = bodies.filter {
      case b if b.stmts.isEmpty && !initial(b.place) => false
      case _                                         => true
    })

  /** All defined and called methods */
  lazy val methods: Set[Method] =
    bodies.flatMap { b => b.calls + b.method }.toSet

  /** All fields */
  lazy val fields: Set[Field] =
    bodies.flatMap { b => b.assigns ++ b.dereferences }.toSet

  /** All referenced types */
  lazy val types: Set[Type] =
    bodies.flatMap { _.types }.toSet ++
      methods.flatMap { case m => m.parameterTypes.toSet + m.declarer + m.returnType } ++
      fields.map(_.declarer)

  lazy val classes: Set[ClassType] =
    types.map(_.baseType).collect { case t: ClassType => t }

  lazy val userClasses: Set[ClassType] =
    classes.filter(b.isUser)

  def typing(ct: ClassType): Set[ClassType] =
    bodies.flatMap(_.typing(ct)).toSet

  /* Compute super types for user types */
  def decls: Set[ClassDecl] =
    for (ct <- userClasses)
      yield ClassDecl(ct,
      Set(ct),
      userClasses.filter(ct.isSubtype(_)) - ct,
      typing(ct).filter(b.isFramework) + ct.meta.ObjectClass,
      fields.filter(_.declarer == ct),
      bodies.filter(_.method.declarer == ct),
      b)
}

/** Declarations of classes and method bodies */
case class ClassDecl(
    // original user class (extremal sub-type)
    t: ClassType,
    // collapsed user classes (including original) 
    collapsed: Set[ClassType],
    // super types
    user: Set[ClassType],
    frameworkSet: Set[ClassType],
    // field declarations
    fields: Set[Field],
    // method declarations
    bodies: List[MethodBody],
    b: FrameworkBoundary) extends Declaration {

  for (c <- collapsed; u <- user)
    assert(c != u && c.isSubtype(u), s"user class collapse: $c not subtype of $u")
  assert(collapsed(t) && !user(t), "user class collapse")
  assert(frameworkSet.size > 0, "must at least include java.lang.Object")

  def methods = bodies.map(_.method).toSet
  def definitions = methods.map(_.definition)
  def overrides = {
    for (
      m <- methods;
      n <- b.overrides(m).toSeq
    ) yield n.declarer
  }.toSet

  lazy val extend = ClassType.bound(user ++ overrides ++ framework)
  lazy val framework = ClassType.bound(frameworkSet)

  def interfaces = extend.filter(_.isInterface).toList
  def abstracts = extend.filterNot(_.isInterface).filterNot(_.name == "java.lang.Object").toList

  /** Has no code (hence, should be erased) */
  def isEmpty =
    fields.isEmpty &&
      bodies.isEmpty &&
      user.isEmpty &&
      framework.size == 1

  /** Ordering relative to framework */
  def order(implicit b: FrameworkBoundary): List[ClassType] =
    extend.filter(b.isFramework).toList.sorted

  /** Versions of the method bodies for a method */
  def declaration(m: Method): MethodDecl = {
    // find distinct bodies
    val versions = bodies.filter(_.method == m).sortBy(_.place.counter)
    MethodDecl(this, m, versions)
  }
}

case class MethodDecl(clazz: ClassDecl,
                      method: Method,
                      versions: List[MethodBody]) extends Declaration

/** Closed universe of user types */
case class Code(c: Connection,
                b: FrameworkBoundary,
                classes: Set[ClassType],
                decls: Set[ClassDecl]) extends web.TextRender {
  def meta = c.meta
  def bodies: List[MethodBody] = decls.flatMap(_.bodies).toList

  /** Merge class declarations if a class has a unique extension */
  def collapseTypes: Code = {
    for (
      d1 <- decls;
      // exactly one user direct sub-type
      sub = decls.filter(_.user(d1.t));
      if sub.size == 1;
      d2 = sub.head;
      // no common methods
      if (d1.definitions & d2.definitions).isEmpty
    ) return copy(decls = decls - d1 - d2 +
      // move members to the sub-type
      ClassDecl(d2.t,
        d1.collapsed ++ d2.collapsed,
        d2.user -- d1.collapsed,
        d1.framework ++ d2.framework,
        d1.fields ++ d2.fields,
        d1.bodies ++ d2.bodies,
        b)).collapseTypes
    this
  }

  /** Sorted declarations (first order by user ID, then framework ID) */
  lazy val declarations: List[ClassDecl] = {
    import scala.math.Ordering.Implicits._
    decls.toList.sortBy(_.t).sortBy(_.order(b))
  }

  /** Framework imports */
  def imports: List[String] =
    (classes ++ declarations.flatMap(_.extend))
      .filterNot(b.isUser)
      .filterNot(PrefixMask("java.lang."))
      .filterNot(_.isPrivate)
      .map(_.toString.replace("$", "."))
      .toList.sorted

  def makeEnv(p: Parameters) = {
    var names: Map[JavaElement, String] = Map()

    // assign names to user classes
    var ti = 0
    for (decl <- declarations) {
      val name =
        if (decl.isEmpty)
          decl.extend.head.sourceName
        else if (p.PrintSourceSymbols)
          decl.t.prettyName
        else
          Var.fresh(decl.order(b).headOption match {
            case Some(head) => "U" + head.sourceName
            case None       => ti += 1; "U" + ti
          }, names.values.toSet)

      for (t <- decl.collapsed)
        names += t -> name
    }

    // assign names to fields
    var fi = 0
    for (
      decl <- declarations;
      f <- decl.fields.toList.sorted
    ) {
      val name =
        if (p.PrintSourceSymbols && !f.isSynthetic) {
          f.name
        } else {
          fi += 1; "f" + fi
        }

      names += f -> name
    }

    Environment(names, mutable.Map[Var, String](), b, c, p)
  }

  def print(p: Parameters) = {
    implicit val e = makeEnv(p)
    declarations.map(text).filter(!_.isEmpty).mkString("\n")
  }
}
